# The theory of five
*Disclaimer : this is just a draft. It is unclear, messy, and may change.*


## Introduction
Many current programs are complicated, disorganised, and bloated : Windows with its performance and bloat issues, Minecraft with its performance and flexibility issues, macOS with its security issues... All of this makes creation of good software is hard, since there's no widely-known universal guidelines that provide a way to create good software. This page proposes five criteria, which every good software should respect. By opposition, it is also possible to check the quality of a software based on those. We will start by describing quickly the criteria, then we will examine them in details.
> In today's digital landscape, many software applications are characterized by complexity, disorganization, and excessive resource consumption. Examples include Windows, which often grapples with performance and bloat issues; Minecraft, which faces challenges related to performance and flexibility; and macOS, which has been criticized for security vulnerabilities. These factors complicate the development of high-quality software, as there are no universally accepted guidelines to ensure excellence in software design. This paper proposes five essential criteria that every effective software application should meet: Security, Speed, Simplicity, Flexibility, and Maintainability. By evaluating software against these criteria, developers can assess its quality and identify areas for improvement. We will begin by briefly outlining each criterion before delving into a detailed examination of their significance and implications.
>
>*Revised version, by ChatGPT*

## The five criteria
These are :
* Security
* Speed
* Simplicity
* Flexibility
* [FIXME: I forgot...]

**TODO : add definitions of these critera, and provide examples**

Security is important for evident reasons ; speed is more than what could be though : effectively, inefficient software does work, but it holds a machine's resources which could be dedicated to other tasks, and sometimes for a lot of time. Furthermore, efficient software tends to work on old or low-end hardware without too many problems, which fights planned obsolescence. Therefore, while a small software running slow is not extremely given it has some importance - let's say, for example, a game -, it may make the user buy new hardware to make it run smoother, while this new hardware could have been avoided if the software was well-made. Simplicity simply makes programming easier : it is always easier to contribute to a project that you fully understand than a project that you only barely do. Also, it reduces the risks of security problems and bugs, by making code easier to analyse by humans. Be that as it may, as the KISS principle said, something simple but that works is always more impressive than something complicated but that doesn't work. Flexibility is a bit harder to catch. It means avoiding any specification, and advocates reusability and making things generic. It will be further described below.